var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// source/memory-store.ts
var calculateNextResetTime = (windowMs) => {
  const resetTime = /* @__PURE__ */ new Date();
  resetTime.setMilliseconds(resetTime.getMilliseconds() + windowMs);
  return resetTime;
};
var MemoryStore = class {
  constructor() {
    /**
     * The duration of time before which all hit counts are reset (in milliseconds).
     */
    __publicField(this, "windowMs");
    /**
     * The map that stores the number of hits for each client in memory.
     */
    __publicField(this, "hits");
    /**
     * The time at which all hit counts will be reset.
     */
    __publicField(this, "resetTime");
    /**
     * Reference to the active timer.
     */
    __publicField(this, "interval");
  }
  /**
   * Method that initializes the store.
   *
   * @param options {Options} - The options used to setup the middleware.
   */
  init(options) {
    this.windowMs = options.windowMs;
    this.resetTime = calculateNextResetTime(this.windowMs);
    this.hits = {};
    this.interval = setInterval(async () => {
      await this.resetAll();
    }, this.windowMs);
    if (this.interval.unref)
      this.interval.unref();
  }
  /**
   * Method to increment a client's hit counter.
   *
   * @param key {string} - The identifier for a client.
   *
   * @returns {IncrementResponse} - The number of hits and reset time for that client.
   *
   * @public
   */
  async increment(key) {
    var _a;
    const totalHits = ((_a = this.hits[key]) != null ? _a : 0) + 1;
    this.hits[key] = totalHits;
    return {
      totalHits,
      resetTime: this.resetTime
    };
  }
  /**
   * Method to decrement a client's hit counter.
   *
   * @param key {string} - The identifier for a client.
   *
   * @public
   */
  async decrement(key) {
    const current = this.hits[key];
    if (current)
      this.hits[key] = current - 1;
  }
  /**
   * Method to reset a client's hit counter.
   *
   * @param key {string} - The identifier for a client.
   *
   * @public
   */
  async resetKey(key) {
    delete this.hits[key];
  }
  /**
   * Method to reset everyone's hit counter.
   *
   * @public
   */
  async resetAll() {
    this.hits = {};
    this.resetTime = calculateNextResetTime(this.windowMs);
  }
  /**
   * Method to stop the timer (if currently running) and prevent any memory
   * leaks.
   *
   * @public
   */
  shutdown() {
    clearInterval(this.interval);
  }
};

// source/lib.ts
var isLegacyStore = (store) => (
  // Check that `incr` exists but `increment` does not - store authors might want
  // to keep both around for backwards compatibility.
  typeof store.incr === "function" && typeof store.increment !== "function"
);
var promisifyStore = (passedStore) => {
  if (!isLegacyStore(passedStore)) {
    return passedStore;
  }
  const legacyStore = passedStore;
  class PromisifiedStore {
    async increment(key) {
      return new Promise((resolve, reject) => {
        legacyStore.incr(
          key,
          (error, totalHits, resetTime) => {
            if (error)
              reject(error);
            resolve({ totalHits, resetTime });
          }
        );
      });
    }
    async decrement(key) {
      return legacyStore.decrement(key);
    }
    async resetKey(key) {
      return legacyStore.resetKey(key);
    }
    async resetAll() {
      if (typeof legacyStore.resetAll === "function")
        return legacyStore.resetAll();
    }
  }
  return new PromisifiedStore();
};
var parseOptions = (passedOptions) => {
  var _a, _b, _c;
  const notUndefinedOptions = omitUndefinedOptions(passedOptions);
  const config = {
    windowMs: 60 * 1e3,
    max: 5,
    message: "Too many requests, please try again later.",
    statusCode: 429,
    legacyHeaders: (_a = passedOptions.headers) != null ? _a : true,
    standardHeaders: (_b = passedOptions.draft_polli_ratelimit_headers) != null ? _b : false,
    requestPropertyName: "rateLimit",
    skipFailedRequests: false,
    skipSuccessfulRequests: false,
    requestWasSuccessful: (_request, response) => response.statusCode < 400,
    skip: (_request, _response) => false,
    keyGenerator(request, _response) {
      if (!request.ip) {
        console.error(
          "WARN | `express-rate-limit` | `request.ip` is undefined. You can avoid this by providing a custom `keyGenerator` function, but it may be indicative of a larger issue."
        );
      }
      return request.ip;
    },
    async handler(request, response, _next, _optionsUsed) {
      response.status(config.statusCode);
      const message = typeof config.message === "function" ? await config.message(
        request,
        response
      ) : config.message;
      if (!response.writableEnded) {
        response.send(message != null ? message : "Too many requests, please try again later.");
      }
    },
    onLimitReached(_request, _response, _optionsUsed) {
    },
    // Allow the options object to be overriden by the options passed to the middleware.
    ...notUndefinedOptions,
    // Note that this field is declared after the user's options are spread in,
    // so that this field doesn't get overriden with an un-promisified store!
    store: promisifyStore((_c = notUndefinedOptions.store) != null ? _c : new MemoryStore())
  };
  if (typeof config.store.increment !== "function" || typeof config.store.decrement !== "function" || typeof config.store.resetKey !== "function" || config.store.resetAll !== void 0 && typeof config.store.resetAll !== "function" || config.store.init !== void 0 && typeof config.store.init !== "function") {
    throw new TypeError(
      "An invalid store was passed. Please ensure that the store is a class that implements the `Store` interface."
    );
  }
  return config;
};
var handleAsyncErrors = (fn) => async (request, response, next) => {
  try {
    await Promise.resolve(fn(request, response, next)).catch(next);
  } catch (error) {
    next(error);
  }
};
var rateLimit = (passedOptions) => {
  const options = parseOptions(passedOptions != null ? passedOptions : {});
  if (typeof options.store.init === "function")
    options.store.init(options);
  const middleware = handleAsyncErrors(
    async (request, response, next) => {
      const skip = await options.skip(request, response);
      if (skip) {
        next();
        return;
      }
      const augmentedRequest = request;
      const key = await options.keyGenerator(request, response);
      const { totalHits, resetTime } = await options.store.increment(key);
      const retrieveQuota = typeof options.max === "function" ? options.max(request, response) : options.max;
      const maxHits = await retrieveQuota;
      augmentedRequest[options.requestPropertyName] = {
        limit: maxHits,
        current: totalHits,
        remaining: Math.max(maxHits - totalHits, 0),
        resetTime
      };
      if (options.legacyHeaders && !response.headersSent) {
        response.setHeader("X-RateLimit-Limit", maxHits);
        response.setHeader(
          "X-RateLimit-Remaining",
          augmentedRequest[options.requestPropertyName].remaining
        );
        if (resetTime instanceof Date) {
          response.setHeader("Date", (/* @__PURE__ */ new Date()).toUTCString());
          response.setHeader(
            "X-RateLimit-Reset",
            Math.ceil(resetTime.getTime() / 1e3)
          );
        }
      }
      if (options.standardHeaders && !response.headersSent) {
        response.setHeader("RateLimit-Limit", maxHits);
        response.setHeader(
          "RateLimit-Remaining",
          augmentedRequest[options.requestPropertyName].remaining
        );
        if (resetTime) {
          const deltaSeconds = Math.ceil(
            (resetTime.getTime() - Date.now()) / 1e3
          );
          response.setHeader("RateLimit-Reset", Math.max(0, deltaSeconds));
        }
      }
      if (options.skipFailedRequests || options.skipSuccessfulRequests) {
        let decremented = false;
        const decrementKey = async () => {
          if (!decremented) {
            await options.store.decrement(key);
            decremented = true;
          }
        };
        if (options.skipFailedRequests) {
          response.on("finish", async () => {
            if (!options.requestWasSuccessful(request, response))
              await decrementKey();
          });
          response.on("close", async () => {
            if (!response.writableEnded)
              await decrementKey();
          });
          response.on("error", async () => {
            await decrementKey();
          });
        }
        if (options.skipSuccessfulRequests) {
          response.on("finish", async () => {
            if (options.requestWasSuccessful(request, response))
              await decrementKey();
          });
        }
      }
      if (maxHits && totalHits === maxHits + 1) {
        options.onLimitReached(request, response, options);
      }
      if (maxHits && totalHits > maxHits) {
        if ((options.legacyHeaders || options.standardHeaders) && !response.headersSent) {
          response.setHeader("Retry-After", Math.ceil(options.windowMs / 1e3));
        }
        options.handler(request, response, next, options);
        return;
      }
      next();
    }
  );
  middleware.resetKey = options.store.resetKey.bind(options.store);
  return middleware;
};
var omitUndefinedOptions = (passedOptions) => {
  const omittedOptions = {};
  for (const k of Object.keys(passedOptions)) {
    const key = k;
    if (passedOptions[key] !== void 0) {
      omittedOptions[key] = passedOptions[key];
    }
  }
  return omittedOptions;
};
var lib_default = rateLimit;
export {
  MemoryStore,
  lib_default as default,
  lib_default as rateLimit
};
